{
  "Java Merge Sort Implementation": {
        "prefix": "mergeSortJava",
        "body": [
            "",
            "",
            "    static void merge(int arr[], int s, int mid, int e) {",
            "        int temp[] = new int[e - s + 1];",
            "      //  int temp2[] = new int[e - s + 1];",
            "        int i = s;",
            "        int j = mid + 1;",
            "        int k = 0;",
            "",
            "        while (i <= mid && j <= e) {",
            "            if (arr[i] > arr[j]) {",
            "                temp[k] = arr[j];",
            "              //  temp2[k] = b[j];",
            "                k++;",
            "                j++;",
            "            } else {",
            "                temp[k] = arr[i];",
            "              //  temp2[k] = b[i];",
            "                k++;",
            "                i++;",
            "            }",
            "        }",
            "",
            "        while (i <= mid) {",
            "            temp[k] = arr[i];",
            "           // temp2[k] = b[i];",
            "            k++;",
            "            i++;",
            "        }",
            "",
            "        while (j <= e) {",
            "            temp[k] = arr[j];",
            "           // temp2[k] = b[j];",
            "            k++;",
            "            j++;",
            "        }",
            "",
            "        for (i = s, k = 0; i <= e; i++, k++) {",
            "            arr[i] = temp[k];",
            "           // b[i] = temp2[k];",
            "        }",
            "    }",
            "",
            "    public static void mergeSort(int arr[], int s, int e) {",
            "        if (s < e) {",
            "            int mid = (s + e) / 2;",
            "            mergeSort(arr, s, mid);",
            "            mergeSort(arr, mid + 1, e);",
            "            merge(arr, s, mid, e);",
            "        }",
            "    }",
            "",
        ],
        "description": "Merge Sort Implementation in Java"
    }
,
  "Swap Array Elements": {
    "prefix": "swap",
    "body": [
        "public static void swap(int[] array, int index1, int index2) {",
        "    int temp = array[index1];",
        "    array[index1] = array[index2];",
        "    array[index2] = temp;",
        "}"
    ],
    "description": "Swap two elements in an array"
},
	"cpboiler": {
        "prefix": "boiler",
        "body": [
          "import java.io.BufferedReader;",
          "import java.io.InputStream;",
          "import java.io.InputStreamReader;",
          "import java.io.IOException;",
          "import java.util.StringTokenizer;",
          "import java.util.LinkedList;",
          "import java.util.Arrays;",
          "import java.util.*;",
          "",
          "public class two {",
          "",
          "    static final int INF = Integer.MAX_VALUE;",
          "    static final long MOD = 1000000007;",
          "",
          "    static class FastScanner {",
          "        BufferedReader br;",
          "        StringTokenizer st;",
          "",
          "        FastScanner(InputStream is) {",
          "            br = new BufferedReader(new InputStreamReader(is));",
          "        }",
          "",
          "        String next() {",
          "            while (st == null || !st.hasMoreTokens()) {",
          "                try {",
          "                    st = new StringTokenizer(br.readLine());",
          "                } catch (IOException e) {",
          "                    e.printStackTrace();",
          "                }",
          "            }",
          "            return st.nextToken();",
          "        }",
          "",
          "        int nextInt() {",
          "            return Integer.parseInt(next());",
          "        }",
          "",
          "        long nextLong() {",
          "            return Long.parseLong(next());",
          "        }",
          "",
          "        double nextDouble() {",
          "            return Double.parseDouble(next());",
          "        }",
          "",
          "        String nextLine() {",
          "            String str = \"\";",
          "            try {",
          "                str = br.readLine();",
          "            } catch (IOException e) {",
          "                e.printStackTrace();",
          "            }",
          "            return str;",
          "        }",
          "    }",
          "",
          "    static class Graph {",
          "        int V;",
          "        LinkedList<Integer>[] adjList;",
          "",
          "        @SuppressWarnings(\"unchecked\")",
          "        Graph(int V) {",
          "            this.V = V;",
          "            adjList = new LinkedList[V];",
          "            for (int i = 0; i < V; i++)",
          "                adjList[i] = new LinkedList<>();",
          "        }",
          "",
          "        void addEdge(int u, int v) {",
          "            adjList[u].add(v);",
          "        }",
          "",
          "        // Add more graph algorithms as needed",
          "    }",
          "",
          
                "static class SegmentTree {",
                "    private int[] arr;",
                "    private int[] minTree;",
                "    private int[] maxTree;",
                "    private int n;",
                "",
                "    public SegmentTree(int[] input) {",
                "        n = input.length;",
                "        arr = input;",
                "        minTree = new int[2 * n];",
                "        maxTree = new int[2 * n];",
                "        buildTree();",
                "    }",
                "",
                "    private void buildTree() {",
                "        // Initialize leaves",
                "        for (int i = 0; i < n; i++) {",
                "            minTree[n + i] = arr[i];",
                "            maxTree[n + i] = arr[i];",
                "        }",
                "",
                "        // Initialize internal nodes",
                "        for (int i = n - 1; i > 0; i--) {",
                "            minTree[i] = Math.min(minTree[2 * i], minTree[2 * i + 1]);",
                "            maxTree[i] = Math.max(maxTree[2 * i], maxTree[2 * i + 1]);",
                "        }",
                "    }",
                "",
                "    public int[] rangeMinMax(int left, int right) {",
                "        int minVal = Integer.MAX_VALUE;",
                "        int maxVal = Integer.MIN_VALUE;",
                "",
                "        for (left += n, right += n; left < right; left >>= 1, right >>= 1) {",
                "            if ((left & 1) == 1) {",
                "                minVal = Math.min(minVal, minTree[left]);",
                "                maxVal = Math.max(maxVal, maxTree[left]);",
                "                left++;",
                "            }",
                "            if ((right & 1) == 1) {",
                "                right--;",
          // additional lines needed for rangeMinMax
                "                minVal = Math.min(minVal, minTree[right]);",
                "                maxVal = Math.max(maxVal, maxTree[right]);",
                "            }",
                "        }",
                "        return new int[] { minVal, maxVal };",
                "    }",
                "",
                "    // Optional: Function to update an element at a specific index",
                "    public void update(int index, int value) {",
                "        index += n;",
                "        minTree[index] = value;",
                "        maxTree[index] = value;",
                "",
                "        for (index >>= 1; index > 0; index >>= 1) {",
                "            minTree[index] = Math.min(minTree[2 * index], minTree[2 * index + 1]);",
                "            maxTree[index] = Math.max(maxTree[2 * index], maxTree[2 * index + 1]);",
                "        }",
                "    }",
                "}",
               
              
            
          
          
          "    static class DSU {",
          "        int[] parent;",
          "        int[] rank;",
          "",
          "        DSU(int n) {",
          "            parent = new int[n];",
          "            rank = new int[n];",
          "            for (int i = 0; i < n; i++) {",
          "                parent[i] = i;",
          "                rank[i] = 0;",
          "            }",
          "        }",
          "",
          "        int find(int x) {",
          "            if (parent[x] != x)",
          "                parent[x] = find(parent[x]);",
          "            return parent[x];",
          "        }",
          "",
          "        void union(int x, int y) {",
          "            int xRoot = find(x);",
          "            int yRoot = find(y);",
          "            if (xRoot == yRoot)",
          "                return;",
          "            if (rank[xRoot] < rank[yRoot])",
          "                parent[xRoot] = yRoot;",
          "            else if (rank[xRoot] > rank[yRoot])",
          "                parent[yRoot] = xRoot;",
          "            else {",
          "                parent[yRoot] = xRoot;",
          "                rank[xRoot]++;",
          "            }",
          "        }",
          "    }",
          "",
          "    static int gcd(int a, int b) {",
          "        while (b != 0) {",
          "            int temp = b;",
          "            b = a % b;",
          "            a = temp;",
          "        }",
          "        return a;",
          "    }",
          "",
          "    static long gcd(long a, long b) {",
          "        while (b != 0) {",
          "            long temp = b;",
          "            b = a % b;",
          "            a = temp;",
          "        }",
          "        return a;",
          "    }",
          "",
          "    static long power(long x, long y, long p) {",
          "        long res = 1;",
          "        x = x % p;",
          "",
          "        while (y > 0) {",
          "            if (y % 2 == 1)",
          "                res = (res * x) % p;",
          "            y = y >> 1;",
          "            x = (x * x) % p;",
          "        }",
          "        return res;",
          "    }",
          "",
          "    static boolean[] sieveOfEratosthenes(int n) {",
          "        boolean[] prime = new boolean[n + 1];",
          "        Arrays.fill(prime, true);",
          "        prime[0] = prime[1] = false;",
          "        for (int p = 2; p * p <= n; p++) {",
          "            if (prime[p]) {",
          "                for (int i = p * p; i <= n; i += p)",
          "                    prime[i] = false;",
          "            }",
          "        }",
          "        return prime;",
          "    }",
          "",
          "    public static void main(String[] args) {",
          "        FastScanner sc = new FastScanner(System.in);",
          "        int t = sc.nextInt();",
          "        while (t > 0) {",
          "            int n = sc.nextInt();",
          "            int k = sc.nextInt();",
          "            int arr[] = new int[n];",
          
          
          
          
          
          
          
          
          "   t--;",
          "        }",
          "    }",
          "}",
          ""
        ],
        "description": "boiler"
      },
      "input":{
        "prefix": "javaArrayInput",
        "body": [
            "for(int i = 0; i < ${1:n}; i++) {",
            "    ${2:arr}[i] = ${3:sc}.nextInt();",
            "}"
        ],
        "description": "A for loop to read integers into an array in Java"
    },
    "Longest Common Substring": {
      "prefix": "lcsub",
      "body": [
          "    public static int lcsub(String s1, String s2) {",
          "        int n = s1.length();",
          "        int m = s2.length();",
          "        char[] a = s1.toCharArray();",
          "        char[] b = s2.toCharArray();",
          "        int[][] dp = new int[n + 1][m + 1];",
          "",
          "        for (int i = 1; i <= n; i++) {",
          "            for (int j = 1; j <= m; j++) {",
          "                if (a[i - 1] == b[j - 1]) {",
          "                    dp[i][j] = dp[i - 1][j - 1] + 1;",
          "                } else {",
          "                    dp[i][j] = 0;",
          "                }",
          "            }",
          "        }",
          "",
          "        int ans = 0;",
          "        for (int i = 0; i <= n; i++) {",
          "            for (int j = 0; j <= m; j++) {",
          "                ans = Math.max(ans, dp[i][j]);",
          "            }",
          "        }",
          "",
          "        return ans;",
          "    }",
      ],
      "description": "Calculate the length of the longest common substring between two strings."
  }
    ,
    
      "Modular Exponentiation Function": {
          "prefix": "modexp",
          "body": [
              "/**",
              " * Function to perform modular exponentiation.",
              " * @param a the base",
              " * @param b the exponent",
              " * @param mod the modulus",
              " * @return (a^b) % mod",
              "for a^b^c do b^c mod-1 and the a^intermidiate mod",
              " */",
              "public static long expo(long a, long b, long mod) {",
              "    long result = 1;",
              "    a = a % mod; // Handle the case when 'a' is greater than mod",
              "    while (b > 0) {",
              "        if ((b & 1) == 1) { // If b is odd, multiply 'a' with result",
              "            result = (result * a) % mod;",
              "        }",
              "        a = (a * a) % mod; // Square 'a'",
              "        b = b >> 1; // Divide b by 2",
              "    }",
              "    return result;",
              "}"
          ],
          "description": "Modular exponentiation function"
      },
      "zfFunction": {
        "prefix": "zfFunction",
        "body": [
            "static int[] zf(String s) {",
            "    int n = s.length();",
            "    int z[] = new int[n];",
            "    char ab[] = s.toCharArray();",
            "    int l = 0;",
            "    int r = 0;",
            "    for (int i = 1; i < n; i++) {",
            "        if (i < r) {",
            "            z[i] = Math.min(r - i, z[i - l]);",
            "        }",
            "        while (i + z[i] < n && ab[z[i]] == ab[i + z[i]]) {",
            "            z[i]++;",
            "        }",
            "        if (i + z[i] > r) {",
            "            l = i;",
            "            r = i + z[i];",
            "        }",
            "    }",
            "    return z;",
            "}"
        ],
        "description": "Z-function implementation"
    },
    
      "Find Difference of Two Strings": {
        "prefix": "findDiff",
        "body": [
          "static boolean isSmaller(String str1, String str2) {",
          "    int n1 = str1.length(), n2 = str2.length();",
          "    if (n1 < n2)",
          "        return true;",
          "    if (n2 < n1)",
          "        return false;",
          "    for (int i = 0; i < n1; i++) {",
          "        if (str1.charAt(i) < str2.charAt(i))",
          "            return true;",
          "        else if (str1.charAt(i) > str2.charAt(i))",
          "            return false;",
          "    }",
          "    return false;",
          "}",
          "static String findDiff(String str1, String str2) {",
          "    if (isSmaller(str1, str2)) {",
          "        String t = str1;",
          "        str1 = str2;",
          "        str2 = t;",
          "    }",
          "    String str = \"\";",
          "    int n1 = str1.length(), n2 = str2.length();",
          "    int diff = n1 - n2;",
          "    int carry = 0;",
          "    for (int i = n2 - 1; i >= 0; i--) {",
          "        int sub = (((int)str1.charAt(i + diff) - (int)'0') - ((int)str2.charAt(i) - (int)'0') - carry);",
          "        if (sub < 0) {",
          "            sub = sub + 10;",
          "            carry = 1;",
          "        } else",
          "            carry = 0;",
          "        str += String.valueOf(sub);",
          "    }",
          "    for (int i = n1 - n2 - 1; i >= 0; i--) {",
          "        if (str1.charAt(i) == '0' && carry > 0) {",
          "            str += \"9\";",
          "            continue;",
          "        }",
          "        int sub = (((int)str1.charAt(i) - (int)'0') - carry);",
          "        if (i > 0 || sub > 0)",
          "            str += String.valueOf(sub);",
          "        carry = 0;",
          "    }",
          "    return new StringBuilder(str).reverse().toString();",
          "}"
        ],
        "description": "Snippet to find the difference of two strings."
      }
    ,
      
        "And Trick Function": {
            "prefix": "and_trick",
            "body": [
                "static class Pair {",
                "    int first;",
                "    int second;",
                "    Pair(int first, int second) {",
                "        this.first = first;",
                "        this.second = second;",
                "    }",
                "}",
                "HashMap<Integer, Long> and_trick(int arr[], int n) {",
                "    HashMap<Integer, Long> and_values = new HashMap<>();",
                "    // Here trick starts: from a particular index value ai there are log(ai) different and values",
                "    HashMap<Integer, Integer> prev_and = new HashMap<>();",
                "    for (int i = n - 1; i >= 0; i--) {",
                "        HashMap<Integer, Integer> next_and = new HashMap<>();",
                "        for (int aa : prev_and.keySet()) {",
                "            if (next_and.containsKey(aa & arr[i])) {",
                "                next_and.put(aa & arr[i], Math.max(next_and.get(aa & arr[i]), prev_and.get(aa)));",
                "            } else {",
                "                next_and.put(aa & arr[i], prev_and.get(aa));",
                "            }",
                "        }",
                "        if (next_and.containsKey(arr[i])) {",
                "            next_and.put(arr[i], Math.max(next_and.get(arr[i]), i));",
                "        } else {",
                "            next_and.put(arr[i], i);",
                "        }",
                "        // hm has (k,v) as (x,y) x tells us that the &value x till index v starting at index i;",
                "        prev_and = next_and;",
                "        ArrayList<Pair> ranges = new ArrayList<>();",
                "        for (int and_val : next_and.keySet()) {",
                "            ranges.add(new Pair(and_val, next_and.get(and_val)));",
                "        }",
                "        Collections.sort(ranges, new Comparator<Pair>() {",
                "            @Override",
                "            public int compare(Pair o1, Pair o2) {",
                "                return o1.second - o2.second;",
                "            }",
                "        });",
                "        // Sorting on the basis of starting index",
                "        // System.out.println(\"Starting at. \" + i);",
                "        for (int j = 0; j < ranges.size(); j++) {",
                "            if (j == 0) {",
                "                // System.out.println(i + \" \" + ranges.get(j).second + \" \" + ranges.get(j).first);",
                "                // [i.....ranges[j].second]; -> val-> ranges.first",
                "                if (and_values.containsKey(ranges.get(j).first)) {",
                "                    and_values.put(ranges.get(j).first, and_values.get(ranges.get(j).first) + (ranges.get(j).second - i + 1));",
                "                } else {",
                "                    and_values.put(ranges.get(j).first, (long) (ranges.get(j).second - i + 1));",
                "                }",
                "            } else {",
                "                // System.out.println((ranges.get(j - 1).second + 1) + \" \" + ranges.get(j).second + \" \" + ranges.get(j).first);",
                "                // [ranges[j-1].second+1 ..... ranges.second]; -> val-> ranges[j].first",
                "                if (and_values.containsKey(ranges.get(j).first)) {",
                "                    and_values.put(ranges.get(j).first, and_values.get(ranges.get(j).first) + (ranges.get(j).second - ranges.get(j - 1).second));",
                "                } else {",
                "                    and_values.put(ranges.get(j).first, (long) (ranges.get(j).second - ranges.get(j - 1).second));",
                "                }",
                "            }",
                "        }",
                "        // Now we have all and values in map and_values with their frequencies of occurrences",
                "    }",
                "    // Now do (and / gcd / or) > k == k < k as required",
                "    return and_values;",
                "}"
            ],
            "description": "HashMap<Integer, Long> and_trick(int arr[], int n)"
        }
    
  
    
     
}
